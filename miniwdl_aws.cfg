# miniwdl configuration file built into the miniwdl-aws Docker image for use with
# miniwdl_submit_awsbatch
#
# For info about where to place this file, and other available options:
#   https://miniwdl.readthedocs.io/en/latest/runner_reference.html#configuration
#
# Additionally, the following are usually set via environment variables:
#   * MINIWDL__AWS__TASK_QUEUE: the desired AWS Batch queue
#   * MINIWDL__AWS__FSAP: EFS Access Point ID (fsap-xxxx)
#   * MINIWDL__AWS__FS: EFS file system ID (fs-xxxx) matching the access point; can be detected if
#                       omitted, but doing so requires IAM permission to DescribeAccessPoints.

[scheduler]
container_backend = aws_batch_job
# One `miniwdl run` process will be able to orchestrate this many concurrent AWS Batch jobs. (This
# controls the size of a thread pool, so setting it too high tends to be counterproductive.)
call_concurrency = 100
# Reduced concurrency limit for URI download jobs; since these are typically S3 downloads that are
# very fast, running many concurrently is likely to overstress EFS.
download_concurrency = 10

[file_io]
# This must be set to the host's mount point for the EFS Access Point. The plugin will also
# configure AWS Batch jobs to mount the filesystem at this same location.
root = /mnt/efs

[task_runtime]
# Default policy to retry spot-terminated jobs (up to three total attempts)
defaults = {
        "docker": "ubuntu:20.04",
        "preemptible": 2
    }

[call_cache]
# Cache call outputs in EFS folder (valid so long as all referenced input & output files remain
# unmodified on EFS).
dir = /mnt/efs/miniwdl_run/_CACHE/call
get = true
put = true

[download_cache]
dir = /mnt/efs/miniwdl_run/_CACHE/download
get = true
put = false
# disable flock on files used from download cache due to EFS' low limits on flocks
flock = false

[aws]
# Last-resort job timeout for AWS Batch to enforce (attemptDurationSeconds)
job_timeout = 864000
# Internal rate-limiting periods (seconds) for AWS Batch API requests
# (may need to be increased if many concurrent workflow runs are planned)
describe_period = 1
submit_period = 1
# "Burn-in" to increase submit_period early on in the workflow run. May be useful to avoid
# overloading EFS/EBS/Batch during the frenzy that tends to occur at workflow startup (e.g. S3
# downloads of many input files), without necessarily harming scheduling QoS in steady state.
# Given burn-in factors B and C, the effective submit_period at T seconds elapsed in the workflow:
#    submit_period' = submit_period*max(1, C-T/B)
# So for example setting B=36, C=100 ramps the submit_period down from 100X to 1X over an hour.
# Exception: doesn't apply when there are zero submitted jobs in non-terminal states.
submit_period_b = 0
submit_period_c = 100
